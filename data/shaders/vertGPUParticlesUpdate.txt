#version 410

layout( location = 0 ) in vec3 Position;
layout( location = 1 ) in vec3 Velocity;
layout( location = 2 ) in float LifeTime;
layout( location = 3 ) in float LifeSpan;

out vec3  vPosition;
out vec3  vVelocity;
out float vLifeTime;
out float vLifeSpan;

uniform float Time;
uniform float DeltaTime;
uniform float LifeMin;
uniform float LifeMax;
uniform float VelocityMin;
uniform float VelocityMax;
uniform float DirectionVariance;
uniform vec3 EmitterPosition;
uniform vec3 EmitterDirection;

const float INVERSE_MAX_UINT = 1.0f / 4294967295.0f;
const float PI = 3.14159265358979f;

//Random number code by Robert Bridson, co-author of "Fluid Simulation for Computer Graphics"
float rand(uint seed, float range) 
{
	uint i = (seed ^ 12345391u) * 2654435769u;
	i ^= (i << 6u) ^ (i >> 26u);
	i *= 2654435769u;
	i += (i << 5u) ^ (i >> 12u);
	return float(range * i) * INVERSE_MAX_UINT;
} 

void main()
{
	vPosition = Position + Velocity * DeltaTime;
	vVelocity = Velocity;
	vLifeTime = LifeTime + DeltaTime;
	vLifeSpan = LifeSpan;
	
	if (vLifeTime > vLifeSpan)
	{
		uint seed = uint(Time * 1000) + uint(gl_VertexID);

		float randAngle = rand(seed++, 2 * PI);
		float randMagnitude = rand(seed++, DirectionVariance);
		float randX = randMagnitude * cos(randAngle);
		float randY = randMagnitude * sin(randAngle);
		//Possibly change this line, not sure if correct.
		vec3 randDir = vec3(cos(randX), 0, sin(randX)) + vec3(cos(randY), sin(randY), 0);
		
		vec3 right = cross(vec3(0, 1, 0), EmitterDirection);
		vec3 up = cross(EmitterDirection, right);
		//Renormalize for incase warping has occured.
		right = normalize(right);
		up = normalize(up);
		mat3 transformMatrix = mat3(EmitterDirection, up, right);//mat3(right, up, EmitterDirection);
		vVelocity = vec3(transformMatrix * randDir);

		//Maybe I could fix this by multiplying by another matrix after transformMatrix.


		vVelocity = (rand(seed++, VelocityMax - VelocityMin) + VelocityMin) * normalize(vVelocity);
		vPosition = EmitterPosition;
		vLifeTime = 0;
		vLifeSpan = rand(seed++, LifeMax - LifeMin) + LifeMin;
	}
}
