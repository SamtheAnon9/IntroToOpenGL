#version 410

layout( location = 0 ) in vec3 Position;
layout( location = 1 ) in vec3 Velocity;
layout( location = 2 ) in float LifeTime;
layout( location = 3 ) in float LifeSpan;

out vec3  vPosition;
out vec3  vVelocity;
out float vLifeTime;
out float vLifeSpan;

uniform float Time;
uniform float DeltaTime;
uniform float LifeMin;
uniform float LifeMax;
uniform float VelocityMin;
uniform float VelocityMax;
uniform float DirectionVariance;
uniform vec3 EmitterPosition;
uniform vec3 EmitterDirection;

const float INVERSE_MAX_UINT = 1.0f / 4294967295.0f;
const float PI = 3.14159265358979f;

//Random number code by Robert Bridson, co-author of "Fluid Simulation for Computer Graphics"
float rand(uint seed, float range) 
{
	uint i = (seed ^ 12345391u) * 2654435769u;
	i ^= (i << 6u) ^ (i >> 26u);
	i *= 2654435769u;
	i += (i << 5u) ^ (i >> 12u);
	return float(range * i) * INVERSE_MAX_UINT;
} 

void main()
{
	vPosition = Position + Velocity * DeltaTime;
	vVelocity = Velocity;
	vLifeTime = LifeTime + DeltaTime;
	vLifeSpan = LifeSpan;
	
	if (vLifeTime > vLifeSpan)
	{
		uint seed = uint(Time * 1000) + uint(gl_VertexID);

		//I'm almost certain that my code for finding a random angle in the correct direction is a horribly innefficent way of doing this, but it's a way I understand.
		//Calculating random direction in unit sphere (note: this is not uniformly distributed)
		float randTheta = rand(seed++, DirectionVariance);
		float randPhi = rand(seed++, 2 * PI);
		//Calculating the polar form of the direction vector. Something is wrong somewhere below this point- the direction vector is not being properly taken into account.
		float dirPhi = atan(EmitterDirection.y, EmitterDirection.x);
		float dirTheta = acos(EmitterDirection.z);
		//Add angles together.
		float phi = randPhi + dirPhi;
		float theta = randTheta + dirTheta;
		//Now, convert back to cartesian coordinates.
		vVelocity = vec3(cos(phi) * sin(theta), sin(phi) * sin(theta), cos(theta));



		////NEED TO CHANGE THE BELOW LINES TO INCLUDE DIRECTIONVARIANCE
		//vVelocity.x = rand(seed++, 2) - 1;
		//vVelocity.y = rand(seed++, 2) - 1;
		//vVelocity.z = rand(seed++, 2) - 1;

		vVelocity = (rand(seed++, VelocityMax - VelocityMin) + VelocityMin) * normalize(vVelocity);
		vPosition = EmitterPosition;
		vLifeTime = 0;
		vLifeSpan = rand(seed++, LifeMax - LifeMin) + LifeMin;
	}
}
